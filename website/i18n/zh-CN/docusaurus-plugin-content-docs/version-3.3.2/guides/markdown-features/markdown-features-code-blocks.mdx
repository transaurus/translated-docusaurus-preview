---
id: code-blocks
description: Handling code blocks in Docusaurus Markdown
slug: /markdown-features/code-blocks
---

# 代码块

import BrowserWindow from '@site/src/components/BrowserWindow';
import CodeBlock from '@theme/CodeBlock';

文档中的代码块拥有超强功能 💪。

## 代码标题 {#code-title}

通过在语言标识后添加 `title` 键（需用空格分隔），可为代码块添加标题。

````md
```jsx title="/src/components/HelloCodeTitle.js"
function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
````

<BrowserWindow>

```jsx title="/src/components/HelloCodeTitle.js"
function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

</BrowserWindow>

## 语法高亮 {#syntax-highlighting}

代码块是由三个反引号包裹的文本块。可查阅 [MDX规范](https://github.com/mdx-js/specification) 了解具体标准。

````md
```js
console.log('Every repo must come with a mascot.');
```
````

为代码块匹配对应的语言元字符串后，Docusaurus 将自动启用由 [Prism React Renderer](https://github.com/FormidableLabs/prism-react-renderer) 驱动的语法高亮功能。

<BrowserWindow>

```js
console.log('Every repo must come with a mascot.');
```

</BrowserWindow>

### 主题定制 {#theming}

默认使用 [Palenight](https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/themes/palenight.ts) 作为 Prism 的[语法高亮主题](https://github.com/FormidableLabs/prism-react-renderer#theming)。可通过修改 docusaurus.config.js 中 `themeConfig` 的 `prism.theme` 字段切换其他主题。

例如切换至 `dracula` 高亮主题：

```js title="docusaurus.config.js"
import {themes as prismThemes} from 'prism-react-renderer';

export default {
  themeConfig: {
    prism: {
      // highlight-next-line
      theme: prismThemes.dracula,
    },
  },
};
```

由于 Prism 主题本质是 JS 对象，您也可以基于默认主题创作自定义主题。Docusaurus 增强了 `github` 和 `vsDark` 主题以提供更丰富的语法高亮，可参考我们对[浅色](https://github.com/facebook/docusaurus/blob/main/website/src/utils/prismLight.ts)和[深色](https://github.com/facebook/docusaurus/blob/main/website/src/utils/prismDark.ts)代码块主题的实现。

### 支持语言 {#supported-languages}

Docusaurus 默认内置了[常用语言子集](https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/generate-prism-languages/index.ts#L9-L23)。

:::warning

Java、C#、PHP 等流行语言默认未启用。

:::

如需支持其他 [Prism兼容语言](https://prismjs.com/#supported-languages)，需在配置数组中声明附加语言。

:::note

每个附加语言必须是有效的 Prism 组件名。例如 Prism 会将语言标识 `cs` 映射到 `csharp`，但只有 `prism-csharp.js` 作为_组件_存在，因此需使用 `additionalLanguages: ['csharp']`。可通过查看 `node_modules/prismjs/components` 目录获取所有可用组件（语言）。

:::

例如添加 PowerShell 语言支持：

```js title="docusaurus.config.js"
export default {
  // ...
  themeConfig: {
    prism: {
      // highlight-next-line
      additionalLanguages: ['powershell'],
    },
    // ...
  },
};
```

添加 `additionalLanguages` 后需重启 Docusaurus。

如需支持 Prism 尚未覆盖的语言，可通过置换 `prism-include-languages` 实现：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic prism-include-languages
```

这将在 `src/theme` 目录生成 `prism-include-languages.js` 文件。通过编辑该文件可添加自定义语言支持：

```js title="src/theme/prism-include-languages.js"
const prismIncludeLanguages = (Prism) => {
  // ...

  additionalLanguages.forEach((lang) => {
    require(`prismjs/components/prism-${lang}`);
  });

  // highlight-next-line
  require('/path/to/your/prism-language-definition');

  // ...
};
```

编写自定义语言定义时，可参考 [Prism官方语言定义](https://github.com/PrismJS/prism/tree/master/components)。

添加自定义语言定义时，您无需将其加入 `additionalLanguages` 配置数组，因为 Docusaurus 仅在 Prism 提供的语言中查找 `additionalLanguages` 字符串。在 `prism-include-languages.js` 中导入语言即可满足需求。

## 行高亮 {#line-highlighting}

### 通过注释实现高亮 {#highlighting-with-comments}

您可使用 `highlight-next-line`、`highlight-start` 和 `highlight-end` 注释来选择需高亮的行。

````md
```js
function HighlightSomeText(highlight) {
  if (highlight) {
    // highlight-next-line
    return 'This text is highlighted!';
  }

  return 'Nothing highlighted';
}

function HighlightMoreText(highlight) {
  // highlight-start
  if (highlight) {
    return 'This range is highlighted!';
  }
  // highlight-end

  return 'Nothing highlighted';
}
```
````

<BrowserWindow>

```js
function HighlightSomeText(highlight) {
  if (highlight) {
    // highlight-next-line
    return 'This text is highlighted!';
  }

  return 'Nothing highlighted';
}

function HighlightMoreText(highlight) {
  // highlight-start
  if (highlight) {
    return 'This range is highlighted!';
  }
  // highlight-end

  return 'Nothing highlighted';
}
```

</BrowserWindow>

支持的注释语法：

| Style      | Syntax                   |
| ---------- | ------------------------ |
| C-style    | `/* ... */` and `// ...` |
| JSX-style  | `{/* ... */}`            |
| Bash-style | `# ...`                  |
| HTML-style | `<!-- ... -->`           |

我们将基于语言类型自动推断适用的注释风格，默认允许使用所有注释风格。若存在未被支持的注释风格，欢迎提交 PR 进行补充。请注意不同注释风格仅形式差异，功能语义完全一致。

您可在 `src/css/custom.css` 中为高亮代码行设置与语法高亮主题更匹配的自定义背景色。下方给出的颜色值适用于默认主题 (Palenight)，若使用其他主题需相应调整颜色值。

```css title="/src/css/custom.css"
:root {
  --docusaurus-highlighted-code-line-bg: rgb(72, 77, 91);
}

/* If you have a different syntax highlighting theme for dark mode. */
[data-theme='dark'] {
  /* Color which works with dark mode syntax highlighting theme */
  --docusaurus-highlighted-code-line-bg: rgb(100, 100, 100);
}
```

如需其他样式定制，可通过 `theme-code-block-highlighted-line` CSS 类进行选择。

### 通过元数据字符串实现高亮 {#highlighting-with-metadata-string}

您也可在语言元字符串中指定高亮行范围（语言后需留空格）。多行高亮可使用逗号分隔行号，或使用范围语法选择连续行。该功能基于 `parse-number-range` 库实现，更多语法请参考[项目文档](https://www.npmjs.com/package/parse-numeric-range)。

````md
```jsx {1,4-6,11}
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```
````

<BrowserWindow>

```jsx {1,4-6,11}
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```

</BrowserWindow>

:::tip[优先使用注释]

建议优先采用注释高亮方式。通过代码内联标注，您无需手动计算长代码块的行号。增删代码行时也无需调整行范围偏移量。

````diff
- ```jsx {3}
+ ```jsx {4}
  function HighlightSomeText(highlight) {
    if (highlight) {
+     console.log('发现高亮文本');
      return '这段文本被高亮！';
    }

    return '无高亮内容';
  }
  ```
````

下文将介绍如何扩展魔法注释系统以定义自定义指令及其功能。仅当不存在高亮元字符串时，系统才会解析魔法注释。

:::

### 自定义魔法注释 {#custom-magic-comments}

`// highlight-next-line` 和 `// highlight-start` 等被称为"魔法注释"，它们会被解析并移除，其作用是为下一行或注释对包裹的代码段添加元数据。

您可通过主题配置声明自定义魔法注释。例如注册一个为代码行添加 `code-block-error-line` 类名的新魔法注释：

<Tabs>
<TabItem value="docusaurus.config.js">

```js
export default {
  themeConfig: {
    prism: {
      magicComments: [
        // Remember to extend the default highlight class name as well!
        {
          className: 'theme-code-block-highlighted-line',
          line: 'highlight-next-line',
          block: {start: 'highlight-start', end: 'highlight-end'},
        },
        // highlight-start
        {
          className: 'code-block-error-line',
          line: 'This will error',
        },
        // highlight-end
      ],
    },
  },
};
```

</TabItem>
<TabItem value="src/css/custom.css">

```css
.code-block-error-line {
  background-color: #ff000020;
  display: block;
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
  border-left: 3px solid #ff000080;
}
```

</TabItem>
<TabItem value="myDoc.md">

````md
In JavaScript, trying to access properties on `null` will error.

```js
const name = null;
// This will error
console.log(name.toUpperCase());
// Uncaught TypeError: Cannot read properties of null (reading 'toUpperCase')
```
````

</TabItem>
</Tabs>

<BrowserWindow>

In JavaScript, trying to access properties on `null` will error.

```js
const name = null;
// This will error
console.log(name.toUpperCase());
// Uncaught TypeError: Cannot read properties of null (reading 'toUpperCase')
```

</BrowserWindow>

若使用元字符串中的数字范围语法（如 `{1,3-4}`），Docusaurus 将应用首个 `magicComments` 条目定义的类名。默认情况下为 `theme-code-block-highlighted-line`，但若修改 `magicComments` 配置并将其他条目置顶，元字符串范围的含义也会相应变化。

可通过 `magicComments: []` 禁用默认行高亮注释。若无魔法注释配置但存在含元字符串范围的代码块，Docusaurus 将报错——毕竟高亮类名本质上就是一个魔法注释条目。

每个魔法注释条目包含三个键：`className`（必填）、`line`（作用于紧邻的下一行）或包含`start`和`end`的`block`（作用于注释对包裹的整个代码块）。

通过CSS定位类名已能实现丰富效果，但通过[组件替换](../../swizzling.mdx)可解锁该功能的全部潜力。

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic CodeBlock/Line
```

`Line`组件将接收类名列表，据此可条件化渲染不同的标记结构。

## 行号显示 {#line-numbering}

在语言元字符串中添加`showLineNumbers`键可启用代码块行号显示（注意键名前需保留空格）。

````md
```jsx {1,4-6,11} showLineNumbers
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```
````

<BrowserWindow>

```jsx {1,4-6,11} showLineNumbers
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```

</BrowserWindow>

## 交互式代码编辑器 {#interactive-code-editor}

（由[React Live](https://github.com/FormidableLabs/react-live)驱动）

通过`@docusaurus/theme-live-codeblock`插件可创建交互式代码编辑器。首先将插件添加到项目依赖中。

```bash npm2yarn
npm install --save @docusaurus/theme-live-codeblock
```

还需在`docusaurus.config.js`中配置该插件。

```js {3}
export default {
  // ...
  themes: ['@docusaurus/theme-live-codeblock'],
  // ...
};
```

使用时，在语言元字符串后附加`live`标记即可。

````md
```jsx live
function Clock(props) {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerID = setInterval(() => tick(), 1000);

    return function cleanup() {
      clearInterval(timerID);
    };
  });

  function tick() {
    setDate(new Date());
  }

  return (
    <div>
      <h2>It is {date.toLocaleTimeString()}.</h2>
    </div>
  );
}
```
````

代码块将渲染为交互式编辑器，代码改动会实时反映在结果面板中。

<BrowserWindow>

```jsx live
function Clock(props) {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerID = setInterval(() => tick(), 1000);

    return function cleanup() {
      clearInterval(timerID);
    };
  });

  function tick() {
    setDate(new Date());
  }

  return (
    <div>
      <h2>It is {date.toLocaleTimeString()}.</h2>
    </div>
  );
}
```

</BrowserWindow>

### 导入依赖 {#imports}

:::warning[react-live与导入限制]

无法直接从react-live代码编辑器导入组件，必须预先定义可用导入项。

:::

默认情况下所有React导入均可用。如需扩展导入范围，请替换react-live作用域组件：

```bash npm2yarn
npm run swizzle @docusaurus/theme-live-codeblock ReactLiveScope -- --eject
```

```jsx title="src/theme/ReactLiveScope/index.js"
import React from 'react';

// highlight-start
const ButtonExample = (props) => (
  <button
    {...props}
    style={{
      backgroundColor: 'white',
      color: 'black',
      border: 'solid red',
      borderRadius: 20,
      padding: 10,
      cursor: 'pointer',
      ...props.style,
    }}
  />
);
// highlight-end

// Add react-live imports you need here
const ReactLiveScope = {
  React,
  ...React,
  // highlight-next-line
  ButtonExample,
};

export default ReactLiveScope;
```

此时`ButtonExample`组件即可使用：

<BrowserWindow>

```jsx live
function MyPlayground(props) {
  return (
    <div>
      <ButtonExample onClick={() => alert('hey!')}>Click me</ButtonExample>
    </div>
  );
}
```

</BrowserWindow>

### 命令式渲染（noInline）

当代码涉及多个组件或变量时，应使用`noInline`选项避免报错。

````md
```jsx live noInline
const project = 'Docusaurus';

const Greeting = () => <p>Hello {project}!</p>;

render(<Greeting />);
```
````

与普通交互式代码块不同，使用`noInline`时React Live不会将代码包裹在内联函数中渲染。

需在代码末尾显式调用`render()`来显示输出结果。

<BrowserWindow>

```jsx live noInline
const project = "Docusaurus";

const Greeting = () => (
  <p>Hello {project}!</p>
);

render(
  <Greeting />
);
```

</BrowserWindow>

## 在代码块中使用JSX标记 {#using-jsx-markup}

Markdown中的代码块始终将其内容保留为纯文本，这意味着无法实现如下操作：

```ts
type EditUrlFunction = (params: {
  // This doesn't turn into a link (for good reason!)
  version: <a href="/docs/versioning">Version</a>;
  versionDocsDirPath: string;
  docPath: string;
  permalink: string;
  locale: string;
}) => string | undefined;
```

如需嵌入HTML标记（如锚链接或加粗文本），可使用`<pre>`标签、`<code>`标签或`<CodeBlock>`组件。

```jsx
<pre>
  <b>Input: </b>1 2 3 4{'\n'}
  <b>Output: </b>"366300745"{'\n'}
</pre>
```

<BrowserWindow>
  <pre>
    <b>{'Input: '}</b>
    {'1 2 3 4\n'}
    <b>{'Output: '}</b>
    {'"366300745"\n'}
  </pre>
</BrowserWindow>

:::warning[MDX对空白符不敏感]

MDX遵循JSX行为规范：即使位于`<pre>`内，换行符也会被转换为空格。必须显式写入换行字符才能输出。

:::

:::warning

语法高亮仅作用于纯字符串。Docusaurus不会解析包含JSX子元素的代码块内容。

:::

## 多语言支持代码块 {#multi-language-support-code-blocks}

借助MDX，您可以在文档中轻松创建交互式组件，例如通过标签页组件展示多种编程语言的代码并实现切换。

我们并未为多语言支持代码块实现专用组件，而是在经典主题中实现了一个通用用途的 [`<Tabs>`](./markdown-features-tabs.mdx) 组件，以便您也能将其用于其他非代码场景。

以下示例展示了如何在文档中实现多语言代码选项卡。请注意每个语言块上下方的空行是**有意保留**的。这是当前 [MDX 的局限性](./markdown-features-react.mdx#markdown-and-jsx-interoperability)：必须在 Markdown 语法周围保留空行，MDX 解析器才能识别这是 Markdown 语法而非 JSX。

````jsx
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="js" label="JavaScript">

```js
function helloWorld() {
  console.log('Hello, world!');
}
```

</TabItem>
<TabItem value="py" label="Python">

```py
def hello_world():
  print("Hello, world!")
```

</TabItem>
<TabItem value="java" label="Java">

```java
class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello, World");
  }
}
```

</TabItem>
</Tabs>
````

您将获得如下效果：

<BrowserWindow>
<Tabs>
<TabItem value="js" label="JavaScript">

```js
function helloWorld() {
  console.log('Hello, world!');
}
```

</TabItem>
<TabItem value="py" label="Python">

```py
def hello_world():
  print("Hello, world!")
```

</TabItem>
<TabItem value="java" label="Java">

```java
class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello, World");
  }
}
```

</TabItem>
</Tabs>
</BrowserWindow>

若存在多个此类多语言代码选项卡，且需要同步不同选项卡实例间的选择状态，请参阅[同步选项卡选择章节](markdown-features-tabs.mdx#syncing-tab-choices)。

### Docusaurus npm2yarn 备注插件 {#npm2yarn-remark-plugin}

同时展示 npm 和 Yarn 的 CLI 命令是常见需求，例如：

```bash npm2yarn
npm install @docusaurus/remark-plugin-npm2yarn
```

Docusaurus 内置了此功能，免去每次使用 `Tabs` 组件的麻烦。启用该功能需先安装 `@docusaurus/remark-plugin-npm2yarn` 包，然后在 `docusaurus.config.js` 中为需要此功能的插件（文档、博客、页面等）在 `remarkPlugins` 选项中注册。（配置格式详见[文档配置](../../api/plugins/plugin-content-docs.mdx#ex-config)）

```js title="docusaurus.config.js"
export default {
  // ...
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-start
          remarkPlugins: [
            [require('@docusaurus/remark-plugin-npm2yarn'), {sync: true}],
          ],
          // highlight-end
        },
        pages: {
          // highlight-next-line
          remarkPlugins: [require('@docusaurus/remark-plugin-npm2yarn')],
        },
        blog: {
          // highlight-start
          remarkPlugins: [
            [
              require('@docusaurus/remark-plugin-npm2yarn'),
              {converters: ['pnpm']},
            ],
          ],
          // highlight-end
          // ...
        },
      },
    ],
  ],
};
```

随后通过在代码块中添加 `npm2yarn` 键来使用：

````md
```bash npm2yarn
npm install @docusaurus/remark-plugin-npm2yarn
```
````

#### 配置项 {#npm2yarn-remark-plugin-configuration}

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `sync` | `boolean` | `false` | Whether to sync the selected converter across all code blocks. |
| `converters` | `array` | `'yarn'`, `'pnpm'` | The list of converters to use. The order of the converters is important, as the first converter will be used as the default choice. |

## 在 JSX 中使用 {#usage-in-jsx}

在 Markdown 之外，您可以使用 `@theme/CodeBlock` 组件获得相同输出。

```jsx
import CodeBlock from '@theme/CodeBlock';

export default function MyReactPage() {
  return (
    <div>
      {/* highlight-start */}
      <CodeBlock
        language="jsx"
        title="/src/components/HelloCodeTitle.js"
        showLineNumbers>
        {`function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}`}
      </CodeBlock>
      {/* highlight-end */}
    </div>
  );
}
```

<BrowserWindow>
  <CodeBlock
    language="jsx"
    title="/src/components/HelloCodeTitle.js"
    showLineNumbers>
    {`function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}`}
  </CodeBlock>
</BrowserWindow>

接受的属性包括 `language`、`title` 和 `showLineNumbers`，其使用方式与编写 Markdown 代码块时相同。

虽然不推荐，但您也可以传递 `metastring` 属性，例如 `metastring='{1-2} title="/src/components/HelloCodeTitle.js" showLineNumbers'`，这是 Markdown 代码块在底层的处理方式。但我们建议您[使用注释进行行高亮](#highlighting-with-comments)。

如前文[所述](#using-jsx-markup)，语法高亮仅在子内容为纯字符串时生效。