---
description: How Docusaurus works to build your app
---

# 架构

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Zoom from 'react-medium-image-zoom';

<Zoom>

![Architecture overview](/img/architecture.png)

</Zoom>

该图表展示了 Docusaurus 构建应用的运作机制。各插件分别收集内容并生成 JSON 数据；主题提供布局组件，这些组件以路由模块形式接收 JSON 数据。打包工具将所有组件打包后输出服务端 bundle 和客户端 bundle。

请注意，虽然您（无论是插件开发者还是站点创建者）始终在编写 JavaScript 代码，但这些代码实际运行在不同环境中：

- 所有插件生命周期方法都在 Node 环境中运行。因此在代码库支持 ES 模块前，插件源码必须提供为可被导入的 ES 模块，或可被 `require` 的 CommonJS 模块
- 主题代码通过 Webpack 构建。可按 ESM 规范提供——遵循 React 约定

插件代码与主题代码从不直接互相导入：它们仅通过协议通信（在本例中通过 JSON 临时文件和 `addRoute` 调用）。一个有效的思维模型是将插件想象为用 Rust 等其他语言编写。用户与插件交互的唯一途径是通过 `docusaurus.config.js` 配置文件，该文件本身在 Node 环境中运行（因此您可以使用 `require` 并传递回调函数作为插件选项）

During bundling, the config file itself is serialized and bundled, allowing the theme to access config options like `themeConfig` or `baseUrl` through [`useDocusaurusContext()`](../docusaurus-core.mdx#useDocusaurusContext). However, the `siteConfig` object only contains **serializable values** (values that are preserved after `JSON.stringify()`). Functions, regexes, etc. would be lost on the client side. The `themeConfig` is designed to be entirely serializable.