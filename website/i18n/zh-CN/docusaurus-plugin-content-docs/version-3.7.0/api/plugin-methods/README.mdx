# 插件方法参考

:::warning

本节内容仍在完善中。锚点链接甚至URL均不保证长期稳定。

:::

插件API由主题和插件共享——主题的加载方式与插件完全相同。

## 插件模块 {#plugin-module}

每个插件都作为模块导入。该模块需包含以下成员：

- **默认导出**：插件的构造函数
- **命名导出**：在插件初始化前调用的[静态方法](./static-methods.mdx)

## 插件构造函数 {#plugin-constructor}

插件模块的默认导出是一个构造函数，其签名为`(context: LoadContext, options: PluginOptions) => Plugin | Promise<Plugin>`。

### `context` {#context}

`context`是与插件无关的通用对象，所有用于Docusaurus网站的插件都会接收到相同的上下文对象。`context`对象包含以下字段：

```ts
type LoadContext = {
  siteDir: string;
  generatedFilesDir: string;
  siteConfig: DocusaurusConfig;
  outDir: string;
  baseUrl: string;
};
```

### `options` {#options}

`options`是[使用插件时的第二个可选参数](../../using-plugins.mdx#configuring-plugins)。`options`是插件特定的配置，由用户在`docusaurus.config.js`中指定。如果导出了[`validateOptions`](./static-methods.mdx#validateOptions)函数，则会先对`options`进行验证和规范化处理。

或者，如果预设(preset)包含该插件，则由预设负责将正确的选项传递给插件。具体接受哪些选项由各个插件自行定义。

## 示例 {#example}

以下是一个假设性插件实现的心智模型。

```js
// A JavaScript function that returns an object.
// `context` is provided by Docusaurus. Example: siteConfig can be accessed from context.
// `opts` is the user-defined options.
export default async function myPlugin(context, opts) {
  return {
    // A compulsory field used as the namespace for directories to cache
    // the intermediate data for each plugin.
    // If you're writing your own local plugin, you will want it to
    // be unique in order not to potentially conflict with imported plugins.
    // A good way will be to add your own project name within.
    name: 'docusaurus-my-project-cool-plugin',

    async loadContent() {
      // The loadContent hook is executed after siteConfig and env has been loaded.
      // You can return a JavaScript object that will be passed to contentLoaded hook.
    },

    async contentLoaded({content, actions}) {
      // The contentLoaded hook is done after loadContent hook is done.
      // `actions` are set of functional API provided by Docusaurus (e.g. addRoute)
    },

    async postBuild(props) {
      // After docusaurus <build> finish.
    },

    // TODO
    async postStart(props) {
      // docusaurus <start> finish
    },

    // TODO
    afterDevServer(app, server) {
      // https://webpack.js.org/configuration/dev-server/#devserverbefore
    },

    // TODO
    beforeDevServer(app, server) {
      // https://webpack.js.org/configuration/dev-server/#devserverafter
    },

    configureWebpack(config, isServer, utils, content) {
      // Modify internal webpack config. If returned value is an Object, it
      // will be merged into the final config using webpack-merge;
      // If the returned value is a function, it will receive the config as the 1st argument and an isServer flag as the 2nd argument.
    },

    getPathsToWatch() {
      // Paths to watch.
    },

    getThemePath() {
      // Returns the path to the directory where the theme components can
      // be found.
    },

    getClientModules() {
      // Return an array of paths to the modules that are to be imported
      // in the client bundle. These modules are imported globally before
      // React even renders the initial UI.
    },

    extendCli(cli) {
      // Register an extra command to enhance the CLI of Docusaurus
    },

    injectHtmlTags({content}) {
      // Inject head and/or body HTML tags.
    },

    async getTranslationFiles({content}) {
      // Return translation files
    },

    translateContent({content, translationFiles}) {
      // translate the plugin content here
    },

    translateThemeConfig({themeConfig, translationFiles}) {
      // translate the site themeConfig here
    },

    async getDefaultCodeTranslationMessages() {
      // return default theme translations here
    },
  };
}

export function validateOptions({options, validate}) {
  const validatedOptions = validate(myValidationSchema, options);
  return validatedOptions;
}

export function validateThemeConfig({themeConfig, validate}) {
  const validatedThemeConfig = validate(myValidationSchema, options);
  return validatedThemeConfig;
}
```