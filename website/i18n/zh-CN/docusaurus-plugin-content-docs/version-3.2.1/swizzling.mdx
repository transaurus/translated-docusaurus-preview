---
description: Customize your site's appearance through creating your own theme components
---

# 组件置换(Swizzling)

本节将介绍如何在Docusaurus中进行布局定制。

> 似曾相识...？

本节内容与[样式与布局](./styling-layout.mdx)类似，但这次我们将定制React组件本身，而非其外观样式。我们将讨论Docusaurus的核心概念：**组件置换(Swizzling)**，该功能允许实现**更深度的站点定制**。

实际操作中，组件置换允许**用您自己的实现替换主题组件**，主要包含两种模式：

- [**弹出(Ejecting)**](#ejecting)：创建原始主题组件的**副本**，您可对其进行**完全自定义**
- [**包装(Wrapping)**](#wrapping)：创建原始主题组件的**包装器**，您可对其进行**功能增强**

<details>

<summary>Why is it called swizzling?</summary>

**The name comes from Objective-C and Swift-UI**: [method swizzling](https://pspdfkit.com/blog/2019/swizzling-in-swift/) is the process of changing the implementation of an existing selector (method).

**For Docusaurus, component swizzling means providing an alternative component that takes precedence over the component provided by the theme.**

You can think of it as [Monkey Patching](https://en.wikipedia.org/wiki/Monkey_patch) for React components, enabling you to override the default implementation. Gatsby has a similar concept called [theme shadowing](https://www.gatsbyjs.com/docs/how-to/plugins-and-themes/shadowing/).

To gain a deeper understanding of this, you have to understand [how theme components are resolved](./advanced/client.mdx#theme-aliases).

</details>

## 置换流程

### 概述

Docusaurus提供了便捷的**交互式CLI**来置换组件，通常只需记住以下命令：

```bash npm2yarn
npm run swizzle
```

该命令将在您的`src/theme`目录下生成新组件，生成文件类似以下示例：

<Tabs>
<TabItem value="Ejecting">

```jsx title="src/theme/SomeComponent.js"
import React from 'react';

export default function SomeComponent(props) {
  // You can fully customize this implementation
  // including changing the JSX, CSS and React hooks
  return (
    <div className="some-class">
      <h1>Some Component</h1>
      <p>Some component implementation details</p>
    </div>
  );
}
```

</TabItem>
<TabItem value="Wrapping">

```jsx title="src/theme/SomeComponent.js"
import React from 'react';
import SomeComponent from '@theme-original/SomeComponent';

export default function SomeComponentWrapper(props) {
  // You can enhance the original component,
  // including adding extra props or JSX elements around it
  return (
    <>
      <SomeComponent {...props} />
    </>
  );
}
```

</TabItem>
</Tabs>

要查看所有可置换主题和组件的概览，请运行：

```bash npm2yarn
npm run swizzle -- --list
```

使用`--help`查看所有可用CLI选项，或参考[swizzle CLI文档](./cli.mdx#docusaurus-swizzle)。

:::note

置换组件后，请**重启开发服务器**以使Docusaurus识别新组件。

:::

:::warning[建议保持安全边界]

请务必理解[哪些组件可以安全置换](#what-is-safe-to-swizzle)。某些组件是主题的**内部实现细节**。

:::

:::info

`docusaurus swizzle`仅是辅助置换组件的自动化工具。您也可以手动创建`src/theme/SomeComponent.js`文件，Docusaurus会[自动解析](./advanced/client.mdx#theme-aliases)。该命令背后并无特殊魔法！

:::

### 弹出(Ejecting) {#ejecting}

弹出主题组件是指**创建原始组件的副本**，您可对该副本进行**完全自定义和重写**。

要弹出主题组件，可使用交互式swizzle CLI或带`--eject`选项执行：

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --eject
```

示例：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --eject
```

此操作会将当前`<Footer />`组件的实现复制到站点的`src/theme`目录。此后Docusaurus将使用该副本而非原始组件。您现在可以完全重新实现`<Footer>`组件。

```jsx title="src/theme/Footer/index.js"
import React from 'react';

export default function Footer(props) {
  return (
    <footer>
      <h1>This is my custom site footer</h1>
      <p>And it is very different from the original</p>
    </footer>
  );
}
```

:::warning

弹出[**不安全**](#what-is-safe-to-swizzle)组件可能导致复制大量内部代码，这些代码需要您自行维护。这会使Docusaurus升级更困难，因为若接收的props或使用的内部主题API发生变化，您需要迁移自定义内容。

**尽可能优先选择[包装模式](#wrapping)**：需要维护的代码量更少。

:::

:::tip[重新置换]

为使弹出的组件在Docusaurus升级后保持最新，请重新执行弹出命令并通过`git diff`比对变更。建议在文件顶部添加简短注释说明您的修改内容，以便在重新弹出后更轻松地重新应用这些更改。

:::

### 包装组件 {#wrapping}

包装主题组件是指**围绕原有主题组件创建包装器**，从而对其进行**功能增强**。

要包装主题组件，可使用交互式 swizzle CLI 或添加 `--wrap` 选项：

```bash npm2yarn
npm run swizzle [theme name] [component name] -- --wrap
```

示例：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic Footer -- --wrap
```

这将在站点的 `src/theme` 目录中创建包装组件。Docusaurus 将使用 `<FooterWrapper>` 组件替代原组件，您可在原始组件周围添加自定义内容。

```jsx title="src/theme/Footer/index.js"
import React from 'react';
import Footer from '@theme-original/Footer';

export default function FooterWrapper(props) {
  return (
    <>
      <section>
        <h2>Extra section</h2>
        <p>This is an extra section that appears above the original footer</p>
      </section>
      <Footer {...props} />
    </>
  );
}
```

<details>
  <summary>What is this <code>@theme-original</code> thing?</summary>

Docusaurus uses [theme aliases](./advanced/client.mdx#theme-aliases) to resolve the theme components to use. The newly created wrapper takes the `@theme/SomeComponent` alias. `@theme-original/SomeComponent` permits to import original component that the wrapper shadows without creating an infinite import loop where the wrapper imports itself.

</details>

:::tip

包装主题是**在不[弹出组件](#ejecting)的前提下，围绕现有组件添加额外元素**的绝佳方式。例如，您可以轻松在每篇博客文章下方添加自定义评论系统：

```jsx title="src/theme/BlogPostItem.js"
import React from 'react';
import BlogPostItem from '@theme-original/BlogPostItem';
import MyCustomCommentSystem from '@site/src/MyCustomCommentSystem';

export default function BlogPostItemWrapper(props) {
  return (
    <>
      <BlogPostItem {...props} />
      <MyCustomCommentSystem />
    </>
  );
}
```

:::

## 哪些组件可以安全替换？ {#what-is-safe-to-swizzle}

> 能力越大，责任越大

部分主题组件属于主题的**内部实现细节**。Docusaurus 允许您替换它们，但这**可能存在风险**。

<details>

<summary>Why is it risky?</summary>

Theme authors (including us) might have to update their theme over time: changing the component props, name, file system location, types... For example, consider a component that receives two props `name` and `age`, but after a refactor, it now receives a `person` prop with the above two properties. Your component, which still expects these two props, will render `undefined` instead.

Moreover, internal components may simply disappear. If a component is called `Sidebar` and it's later renamed to `DocSidebar`, your swizzled component will be completely ignored.

**Theme components marked as unsafe may change in a backward-incompatible way between theme minor versions.** When upgrading a theme (or Docusaurus), your customizations might **behave unexpectedly**, and can even **break your site**.

</details>

对于每个主题组件，swizzle CLI 会标注主题作者声明的**三个安全等级**：

- **安全**：该组件可安全替换，其公共 API 被视为稳定，在主题**主版本**内不会发生破坏性变更
- **不安全**：该组件是主题实现细节，替换不安全，在主题**次版本**升级时可能发生破坏性变更
- **禁止**：swizzle CLI 会阻止您替换该组件，因其设计初衷就禁止被替换

:::note

某些组件可能适合包装但不适合弹出。

:::

:::info

不必**过度担忧替换不安全组件**：只需注意**破坏性变更**可能发生，在次版本升级时可能需要手动调整定制内容。

:::

:::note[提交您的用例]

如果您有**必须替换不安全组件的强烈需求**，请[**在此提交报告**](https://github.com/facebook/docusaurus/discussions/5468)，我们将共同寻找使其安全的解决方案。

:::

## 应该替换哪个组件？ {#which-component-should-i-swizzle}

有时难以准确判断应该替换哪个组件才能实现预期效果。提供大多数主题组件的 `@docusaurus/theme-classic` 包含约 [100 个组件](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)！

:::tip

要查看所有 `@docusaurus/theme-classic` 组件的概览：

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic -- --list
```

:::

您可以通过以下步骤定位需要替换的组件：

1. **组件描述**。部分组件会提供简短描述，这是快速定位目标组件的有效方式。
2. **组件名称**。官方主题组件采用语义化命名，通常可通过名称推断其功能。使用交互式swizzle CLI时，输入组件名称片段即可筛选相关选项。例如执行`yarn swizzle @docusaurus/theme-classic`后输入`Doc`，将仅显示文档相关的组件列表。
3. **从高层级组件入手**。组件之间存在树形结构关系，每个路由会关联一个顶级渲染组件（多数列在[内容插件路由](./advanced/routing.mdx#routing-in-content-plugins)中）。例如所有博客文章页面的最外层组件都是`@theme/BlogPostPage`。可先swizzle该组件，再沿组件树向下定位具体目标组件。定位后请及时删除其他非必要组件文件，避免维护过多自定义组件。
4. **查阅[主题源码](https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-classic/src/theme)**并善用搜索功能。

:::tip[直接提问！]

若仍无法确定应swizzle哪个组件来实现预期效果，可通过我们的[支持渠道](/community/support)寻求帮助。

我们也非常希望了解您最前沿的定制需求，欢迎[提交反馈](https://github.com/facebook/docusaurus/discussions/5468)。

:::

## 是否必须swizzle？ {#do-i-need-to-swizzle}

Swizzle意味着您需要维护与Docusaurus内部API交互的React代码。在定制站点时，请优先考虑以下替代方案：

1. **使用CSS**。CSS规则和选择器通常能实现相当程度的定制效果，详见[样式与布局](./styling-layout.mdx)。
2. **利用国际化机制**。虽然看似意外，但翻译本质上是定制文本标签的途径。例如当站点默认语言为`en`时，仍可执行`yarn write-translations -l en`后编辑生成的`code.json`文件，具体参考[i18n教程](./i18n/i18n-tutorial.mdx)。

:::tip

**组件粒度越小越好**。若必须swizzle，请仅定制相关部分并尽量减少自主维护的代码量。swizzle小型组件通常能降低升级时的**破坏性变更**风险。

相比[完全替换(ejecting)](#ejecting)，[包装组件(wrapping)](#wrapping)也是更安全的选择。

:::

## 使用`<Root>`包装站点 {#wrapper-your-site-with-root}

`<Root>`组件在React树的最顶层渲染（位于主题`<Layout>`之上），且**永远不会卸载**。这是添加跨页面导航时无需重新初始化状态逻辑（用户认证状态、购物车状态等）的理想位置。

通过创建`src/theme/Root.js`文件进行**手动**swizzle：

```js title="src/theme/Root.js"
import React from 'react';

// Default implementation, that you can customize
export default function Root({children}) {
  return <>{children}</>;
}
```

:::tip

建议在此组件中渲染React Context提供器。

:::