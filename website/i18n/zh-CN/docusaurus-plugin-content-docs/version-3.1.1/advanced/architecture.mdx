---
description: How Docusaurus works to build your app
---

# 架构

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Zoom from 'react-medium-image-zoom';

<Zoom>

![Architecture overview](/img/architecture.png)

</Zoom>

该图表展示了Docusaurus构建应用的运作机制。各插件分别收集其内容并生成JSON数据；主题则提供布局组件，这些组件通过路由模块接收JSON数据。打包工具将所有组件打包后，输出服务端包和客户端包。

尽管您（无论是插件开发者还是站点创建者）始终在编写JavaScript代码，但请注意这些代码实际运行于不同环境：

- 所有插件生命周期方法均在Node环境中运行。因此，在代码库支持ES模块之前，插件源代码必须以可被导入的ES模块或可被`require`的CommonJS形式提供。
- 主题代码通过Webpack构建。它们可遵循React惯例以ESM形式提供。

插件代码与主题代码从不直接相互引用：它们仅通过协议进行通信（在本例中通过JSON临时文件和`addRoute`调用）。一个有用的思维模型是将插件想象为用Rust等其他语言编写。用户与插件交互的唯一途径是通过`docusaurus.config.js`文件，该文件本身运行于Node环境（因此您可以使用`require`并传递回调函数作为插件选项）。

在打包过程中，配置文件会被序列化并打包，使得主题能通过[`useDocusaurusContext()`](../docusaurus-core.mdx#useDocusaurusContext)访问诸如`themeConfig`或`baseUrl`等配置选项。但需注意，`siteConfig`对象仅包含**可序列化值**（即经`JSON.stringify()`处理后保留的值）。函数、正则表达式等类型数据将在客户端丢失。`themeConfig`被设计为完全可序列化的配置对象。