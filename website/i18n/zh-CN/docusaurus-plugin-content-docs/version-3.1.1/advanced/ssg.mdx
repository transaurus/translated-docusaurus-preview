---
sidebar_label: Static site generation
description: Docusaurus statically renders your React code into HTML, allowing faster load speed and better SEO.
---

# 静态站点生成（SSG）

在[架构说明](architecture.mdx)中，我们提到主题是在Webpack中运行的。但请注意：这并不意味着它始终能访问浏览器全局变量！主题会经历两次构建：

- **服务端渲染**期间，主题会在名为[React DOM Server](https://reactjs.org/docs/react-dom-server.html)的沙箱中编译。你可以将其视为"无头浏览器"，其中不存在`window`或`document`对象，只有React。SSR会生成静态HTML页面。
- **客户端渲染**期间，主题会被编译成最终在浏览器中执行的JavaScript，因此可以访问浏览器变量。

:::info[SSR还是SSG？]

严格来说，_服务端渲染_和_静态站点生成_是不同的概念，但我们将其混用。

Docusaurus本质上属于静态站点生成器，因为不存在服务端运行时——我们会将内容预渲染为HTML文件部署在CDN上，而非每次请求时动态预渲染。这与[Next.js](https://nextjs.org/)的工作模式不同。

:::

因此，虽然你可能知道不应访问Node全局变量如`process`（[真的不能吗？](#node-env)）或`'fs'`模块，但同样不能随意访问浏览器全局变量。

```jsx
import React from 'react';

export default function WhereAmI() {
  return <span>{window.location.href}</span>;
}
```

以下代码看似符合React惯例，但执行`docusaurus build`时会报错：

```
ReferenceError: window is not defined
```

这是因为在服务端渲染期间，Docusaurus应用并非运行在浏览器环境中，无法识别`window`对象。

<details id="node-env">
<summary>What about <code>process.env.NODE_ENV</code>?</summary>

One exception to the "no Node globals" rule is `process.env.NODE_ENV`. In fact, you can use it in React, because Webpack injects this variable as a global:

```jsx
import React from 'react';

export default function expensiveComp() {
  if (process.env.NODE_ENV === 'development') {
    return <>This component is not shown in development</>;
  }
  const res = someExpensiveOperationThatLastsALongTime();
  return <>{res}</>;
}
```

During Webpack build, the `process.env.NODE_ENV` will be replaced with the value, either `'development'` or `'production'`. You will then get different build results after dead code elimination:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="Development">

```diff
import React from 'react';

export default function expensiveComp() {
  // highlight-next-line
  if ('development' === 'development') {
+   return <>This component is not shown in development</>;
  }
- const res = someExpensiveOperationThatLastsALongTime();
- return <>{res}</>;
}
```

</TabItem>
<TabItem value="Production">

```diff
import React from 'react';

export default function expensiveComp() {
  // highlight-next-line
- if ('production' === 'development') {
-   return <>This component is not shown in development</>;
- }
+ const res = someExpensiveOperationThatLastsALongTime();
+ return <>{res}</>;
}
```

</TabItem>
</Tabs>
</details>

## 理解SSR机制 {#understanding-ssr}

React不仅是动态UI运行时——它还是模板引擎。由于Docusaurus站点主要包含静态内容，它应该能在没有JavaScript（React的运行环境）的情况下仅通过HTML/CSS工作。这正是服务端渲染提供的功能：将React代码静态渲染为HTML，不含任何动态内容。HTML文件没有客户端状态的概念（纯标记语言），因此不应依赖浏览器API。

当用户访问URL时（参见[路由说明](routing.mdx)），这些HTML文件会最先抵达浏览器。之后浏览器才会加载并执行其他JS代码来提供网站的"动态"部分——即任何通过JavaScript实现的功能。但在此之前，页面的主要内容已经可见，从而实现更快加载。

在纯CSR应用中，所有DOM元素都由React在客户端生成，HTML文件仅包含一个供React挂载DOM的根元素；而在SSR中，React面对的是已构建完成的HTML页面，只需将DOM元素与其虚拟DOM模型关联。这一步骤称为"注水"(hydration)。完成注水后，应用开始像普通React应用一样运行。

需要注意的是，Docusaurus本质上是单页应用(SPA)，静态站点生成只是一种优化手段（称为_渐进增强_），我们的功能并不完全依赖这些HTML文件。这与[Jekyll](https://jekyllrb.com/)和[Docusaurus v1](https://v1.docusaurus.io/)等站点生成器有本质区别——后者所有文件都被静态转换为标记，交互性通过`<script>`标签引入的外部JavaScript实现。如果检查构建输出，你仍会看到`build/assets/js`目录下的JS资源，它们才是Docusaurus的核心。

## 应急方案 {#escape-hatches}

如果你需要渲染任何依赖浏览器API才能正常工作的动态内容，例如：

- 我们的[实时代码块](../guides/markdown-features/markdown-features-code-blocks.mdx#interactive-code-editor)（运行于浏览器JS运行时环境）
- 能根据用户色彩方案切换显示图片的[主题化图片](../guides/markdown-features/markdown-features-assets.mdx#themed-images)
- 调试面板中使用`window`全局变量进行样式控制的JSON查看器

由于静态HTML在不了解客户端状态时无法显示有效内容，您可能需要规避服务端渲染(SSR)。

:::warning

关键注意事项：首次客户端渲染必须生成与服务端渲染完全一致的DOM结构，否则React会将虚拟DOM与错误的DOM元素建立关联。

因此，简单的`if (typeof window !== 'undefined) {/* 渲染内容 */}`浏览器检测方案并不适用，因为首次客户端渲染会立即生成与服务端不同的标记。

更多技术细节请参阅《Rehydration的隐患》[The Perils of Rehydration](https://www.joshwcomeau.com/react/the-perils-of-rehydration/)。
:::

我们提供了几种更可靠的SSR规避方案。

### `<BrowserOnly>` {#browseronly}

若某些组件必须依赖浏览器环境（例如使用了浏览器特有API），常规做法是使用[`<BrowserOnly>`](../docusaurus-core.mdx#browseronly)组件包裹，确保其仅在客户端渲染(CSR)时显示，服务端渲染(SSR)时隐藏。

```jsx
import BrowserOnly from '@docusaurus/BrowserOnly';

function MyComponent(props) {
  return (
    // highlight-start
    <BrowserOnly fallback={<div>Loading...</div>}>
      {() => {
        const LibComponent =
          require('some-lib-that-accesses-window').LibComponent;
        return <LibComponent {...props} />;
      }}
    </BrowserOnly>
    // highlight-end
  );
}
```

需特别注意：`<BrowserOnly>`的子元素不是JSX元素，而是返回元素的函数。这是刻意设计。观察以下代码：

```jsx
import BrowserOnly from '@docusaurus/BrowserOnly';

function MyComponent() {
  return (
    <BrowserOnly>
      {/* highlight-start */}
      {/* DON'T DO THIS - doesn't actually work */}
      <span>page url = {window.location.href}</span>
      {/* highlight-end */}
    </BrowserOnly>
  );
}
```

虽然预期`BrowserOnly`会在服务端隐藏子元素，但实际上无法实现。React渲染器处理JSX树时，会直接看到`{window.location.href}`变量节点并尝试渲染（尽管实际未使用）。通过函数形式可确保仅在需要时才让渲染器感知浏览器专用组件。

### `useIsBrowser` {#useisbrowser}

也可使用`useIsBrowser()`钩子检测当前是否处于浏览器环境：SSR返回`false`，首次客户端渲染后返回`true`。适用于仅需在客户端执行条件操作，而非完全变更UI的场景。

```jsx
import useIsBrowser from '@docusaurus/useIsBrowser';

function MyComponent() {
  const isBrowser = useIsBrowser();
  const location = isBrowser ? window.location.href : 'fetching location...';
  return <span>{location}</span>;
}
```

### `useEffect` {#useeffect}

最后可将逻辑置于`useEffect()`中延迟到首次CSR后执行，最适合仅需执行副作用但不依赖客户端状态数据的场景。

```jsx
function MyComponent() {
  useEffect(() => {
    // Only logged in the browser console; nothing is logged during server-side rendering
    console.log("I'm now in the browser");
  }, []);
  return <span>Some content...</span>;
}
```

### `ExecutionEnvironment` {#executionenvironment}

[`ExecutionEnvironment`](../docusaurus-core.mdx#executionenvironment)命名空间下的`canUseDOM`是有效的浏览器环境检测方案。

注意：其底层原理是检测`typeof window !== 'undefined'`，因此不应用于渲染逻辑，仅适用于响应式操作（如用户交互触发的网络请求）或动态加载库等不涉及DOM更新的命令式代码。

```js title="a-client-module.js"
import ExecutionEnvironment from '@docusaurus/ExecutionEnvironment';

if (ExecutionEnvironment.canUseDOM) {
  document.title = "I'm loaded!";
}
```