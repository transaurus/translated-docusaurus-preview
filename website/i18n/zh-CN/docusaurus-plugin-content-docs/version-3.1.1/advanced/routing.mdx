---
description: "Docusaurus' routing system follows single-page application conventions: one route, one component."
---

# 路由系统

import Link from '@docusaurus/Link';
import {useLatestVersion, useActiveDocContext} from '@docusaurus/plugin-content-docs/client';
import {useLocation} from '@docusaurus/router';
import BrowserWindow from '@site/src/components/BrowserWindow';

Docusaurus的路由系统遵循单页应用(SPA)规范：一个路由对应一个组件。本节将首先介绍三大内容插件（文档、博客和页面）内部的路由机制，进而深入探讨底层路由系统的工作原理。

## 内容插件中的路由 {#routing-in-content-plugins}

每个内容插件都提供`routeBasePath`配置项，用于定义插件路由的挂载基点。默认情况下，文档插件将路由挂载在`/docs`下，博客插件挂载在`/blog`下，页面插件则直接挂载在`/`根路径。其路由结构可理解为：

```mermaid
graph LR;
    A(["https://example.com/"])
    B(["/base-url/"])
    C(["/docs/"])
    D(["/blog/"])
    E(["/"])
    F["All docs <br/>routes"]
    G["All blog <br/>routes"]
    H["All pages <br/>routes"]
    A---B;
    B---C;
    B---D;
    B---E;
    C---F;
    D---G;
    E---H;
```

系统会逐级匹配路由配置直至找到对应项。例如当访问`/docs/configuration`路由时，Docusaurus会先进入`/docs`分支，然后在文档插件创建的子路由中进行搜索。

修改`routeBasePath`可重构站点路由体系。如在[纯文档模式](../guides/docs/docs-introduction.mdx#docs-only-mode)中，将文档插件的`routeBasePath`设为`'/'`意味着所有文档路由将去除`/docs`前缀，同时仍允许其他插件创建如`/blog`之类的子路由。

接下来我们具体分析三大插件各自的路由结构。

### 页面路由 {#pages-routing}

页面路由采用直接映射机制：文件路径即URL路径，不支持其他定制方式。详见[页面文档](../guides/creating-pages.mdx#routing)。

Markdown页面使用`@theme/MDXPage`组件渲染，React页面则直接作为路由组件使用。

### 博客路由 {#blog-routing}

博客插件创建以下路由类型：

- **文章列表页**：`/`、`/page/2`、`/page/3`...
  - 使用`@theme/BlogListPage`组件
- **文章详情页**：`/2021/11/21/algolia-docsearch-migration`、`/2021/05/12/announcing-docusaurus-two-beta`...
  - 由每篇Markdown文章生成
  - 可通过`slug`Front Matter完全自定义路由
  - 使用`@theme/BlogPostPage`组件
- **标签列表页**：`/tags`
  - 路由可通过`tagsBasePath`选项配置
  - 使用`@theme/BlogTagsListPage`组件
- **标签聚合页**：`/tags/adoption`、`/tags/beta`...
  - 根据文章Front Matter中定义的标签生成
  - 基础路径由`tagsBasePath`确定，子路径可通过标签的`permalink`字段定制
  - 使用`@theme/BlogTagsPostsPage`组件
- **归档页**：`/archive`
  - 路由可通过`archiveBasePath`选项配置
  - 使用`@theme/BlogArchivePage`组件

### 文档路由 {#docs-routing}

文档插件是唯一支持**嵌套路由**的插件。顶层注册的[版本路径](../guides/docs/versioning.mdx)包括：`/`、`/next`、`/2.0.0-beta.13`...这些路径提供版本上下文（含布局和侧边栏），确保切换文档时侧边栏状态得以保持，同时可通过导航栏下拉菜单切换版本而不改变当前文档。使用`@theme/DocPage`组件渲染。

export const URLPath = () => <code>{useLocation().pathname}</code>;

export const FilePath = () => {
  const currentVersion = useActiveDocContext('default').activeVersion.name;
  return <code>{currentVersion === 'current' ? './docs/' : `./versioned_docs/version-${currentVersion}/`}advanced/routing.md</code>;
}

具体文档内容在导航栏、页脚、侧边栏等`DocPage`组件提供的框架内渲染。例如当前页面<URLPath />由文件<FilePath />生成，使用`@theme/DocItem`组件渲染。

文档的 `slug` 前置元数据可自定义路由的最后部分，但基础路由始终由插件的 `routeBasePath` 和版本的 `path` 定义。

### 文件路径与URL路径 {#file-paths-and-url-paths}

在文档中，我们始终明确区分文件路径和URL路径。内容插件通常直接将文件路径映射为URL路径，例如 `./docs/advanced/routing.md` 会转换为 `/docs/advanced/routing`。但通过 `slug` 配置，您可以使URL与文件结构完全解耦。

在Markdown中编写链接时，您可能指向的是_文件路径_或_URL路径_，Docusaurus会通过以下启发式规则进行判断：

- 若路径带有 `@site` 前缀，则始终视为资源文件路径
- 若路径带有 `http(s)://` 前缀，则始终视为URL路径
- 若路径无扩展名，则视为URL路径。例如在URL为 `/docs/advanced/routing` 的页面上，链接 `[page](../plugins)` 将指向 `/docs/plugins`。Docusaurus仅在构建站点时（当知晓完整路由结构后）检测损坏链接，不会对文件存在性做任何假设。这等同于在JSX文件中编写 `<a href="../plugins">page</a>`
- 若路径带有 `.md(x)` 扩展名，Docusaurus会尝试将该Markdown文件解析为URL路径
- 若路径带有其他扩展名，Docusaurus会将其视为[静态资源](../guides/markdown-features/markdown-features-assets.mdx)并进行打包

以下目录结构可帮助您理解这种文件→URL的映射关系（假设所有页面均未使用slug自定义）：

<details>

<summary>A sample site structure</summary>

```bash
.
├── blog                            # blog plugin has routeBasePath: '/blog'
│   ├── 2019-05-28-first-blog-post.md       # -> /blog/2019/05/28/first-blog-post
│   ├── 2019-05-29-long-blog-post.md        # -> /blog/2019/05/29/long-blog-post
│   ├── 2021-08-01-mdx-blog-post.mdx        # -> /blog/2021/08/01/mdx-blog-post
│   └── 2021-08-26-welcome
│       ├── docusaurus-plushie-banner.jpeg
│       └── index.md                        # -> /blog/2021/08/26/welcome
├── docs                            # docs plugin has routeBasePath: '/docs'; current version has base path '/'
│   ├── intro.md                            # -> /docs/intro
│   ├── tutorial-basics
│   │   ├── _category_.json
│   │   ├── congratulations.md              # -> /docs/tutorial-basics/congratulations
│   │   └── markdown-features.mdx           # -> /docs/tutorial-basics/markdown-features
│   └── tutorial-extras
│       ├── _category_.json
│       ├── manage-docs-versions.md         # -> /docs/tutorial-extras/manage-docs-versions
│       └── translate-your-site.md          # -> /docs/tutorial-extras/translate-your-site
├── src
│   └── pages                       # pages plugin has routeBasePath: '/'
│       ├── index.module.css
│       ├── index.tsx                       # -> /
│       └── markdown-page.md                # -> /markdown-page
└── versioned_docs
    └── version-1.0.0               # version has base path '/1.0.0'
        ├── intro.md                        # -> /docs/1.0.0/intro
        ├── tutorial-basics
        │   ├── _category_.json
        │   ├── congratulations.md          # -> /docs/1.0.0/tutorial-basics/congratulations
        │   └── markdown-features.mdx       # -> /docs/1.0.0/tutorial-basics/markdown-features
        └── tutorial-extras
            ├── _category_.json
            ├── manage-docs-versions.md     # -> /docs/1.0.0/tutorial-extras/manage-docs-versions
            └── translate-your-site.md      # -> /docs/1.0.0/tutorial-extras/translate-your-site
```

</details>

关于内容插件的介绍到此为止。现在让我们退一步，讨论Docusaurus应用中的通用路由机制。

## 路由生成HTML文件 {#routes-become-html-files}

由于Docusaurus是服务端渲染框架，所有生成的路由都会被服务端渲染为静态HTML文件。若您熟悉[Apache2](https://httpd.apache.org/docs/trunk/getting-started.html)等HTTP服务器的行为，就会理解其工作原理：当浏览器请求路由 `/docs/advanced/routing` 时，服务器会将其解析为对HTML文件 `/docs/advanced/routing/index.html` 的请求并返回该文件。

路由 `/docs/advanced/routing` 可能对应 `/docs/advanced/routing/index.html` 或 `/docs/advanced/routing.html`。部分托管服务商通过尾部斜杠区分这两种形式，且可能不兼容另一种形式。详见[尾部斜杠指南](https://github.com/slorber/trailing-slash-guide)。

例如上述目录结构的构建输出如下（忽略其他资源和JS包）：

<details>

<summary>Output of the above workspace</summary>

```bash
build
├── 404.html                      # /404/
├── blog
│   ├── archive
│   │   └── index.html            # /blog/archive/
│   ├── first-blog-post
│   │   └── index.html            # /blog/first-blog-post/
│   ├── index.html                # /blog/
│   ├── long-blog-post
│   │   └── index.html            # /blog/long-blog-post/
│   ├── mdx-blog-post
│   │   └── index.html            # /blog/mdx-blog-post/
│   ├── tags
│   │   ├── docusaurus
│   │   │   └── index.html        # /blog/tags/docusaurus/
│   │   ├── hola
│   │   │   └── index.html        # /blog/tags/hola/
│   │   └── index.html            # /blog/tags/
│   └── welcome
│       └── index.html            # /blog/welcome/
├── docs
│   ├── 1.0.0
│   │   ├── intro
│   │   │   └── index.html        # /docs/1.0.0/intro/
│   │   ├── tutorial-basics
│   │   │   ├── congratulations
│   │   │   │   └── index.html    # /docs/1.0.0/tutorial-basics/congratulations/
│   │   │   └── markdown-features
│   │   │       └── index.html    # /docs/1.0.0/tutorial-basics/markdown-features/
│   │   └── tutorial-extras
│   │       ├── manage-docs-versions
│   │       │   └── index.html    # /docs/1.0.0/tutorial-extras/manage-docs-versions/
│   │       └── translate-your-site
│   │           └── index.html    # /docs/1.0.0/tutorial-extras/translate-your-site/
│   ├── intro
│   │   └── index.html            # /docs/1.0.0/intro/
│   ├── tutorial-basics
│   │   ├── congratulations
│   │   │   └── index.html        # /docs/tutorial-basics/congratulations/
│   │   └── markdown-features
│   │       └── index.html        # /docs/tutorial-basics/markdown-features/
│   └── tutorial-extras
│       ├── manage-docs-versions
│       │   └── index.html        # /docs/tutorial-extras/manage-docs-versions/
│       └── translate-your-site
│           └── index.html        # /docs/tutorial-extras/translate-your-site/
├── index.html                    # /
└── markdown-page
    └── index.html                # /markdown-page/
```

</details>

若将 `trailingSlash` 设为 `false`，构建时将生成 `intro.html` 而非 `intro/index.html`。

所有HTML文件都使用绝对URL引用其JS资源，因此必须配置 `baseUrl` 字段以确保正确加载资源。请注意 `baseUrl` 不会影响构建产物的文件结构：基础URL位于Docusaurus路由系统之上的一级。您可以将 `url` 和 `baseUrl` 的组合视为Docusaurus站点的实际部署位置。

例如，生成的HTML文件中会包含类似`<link rel="preload" href="/assets/js/runtime~main.7ed5108a.js" as="script">`的链接。由于绝对URL是从主机地址解析的，如果打包文件被放置在`https://example.com/base/`路径下，该链接将指向不存在的`https://example.com/assets/js/runtime~main.7ed5108a.js`。通过指定`/base/`作为基础URL，链接才能正确指向`/base/assets/js/runtime~main.7ed5108a.js`。

本地化站点的基本URL中也包含语言环境标识。例如，`https://docusaurus.io/zh-CN/docs/advanced/routing/`的基础URL是`/zh-CN/`。

## 路由的生成与访问 {#generating-and-accessing-routes}

`addRoute`生命周期操作用于生成路由。它将路由配置注册到路由树中，提供路由路径、组件以及组件所需的props。props和组件都以路径形式提供给打包器进行`require`调用，正如[架构概述](architecture.mdx)所解释的，服务端和客户端仅通过临时文件进行通信。

所有路由都聚合在`.docusaurus/routes.js`中，可通过调试插件的[路由面板](/__docusaurus/debug/routes)查看。

在客户端，我们提供`@docusaurus/router`来访问页面路由。`@docusaurus/router`是对[`react-router-dom`](https://www.npmjs.com/package/react-router-dom/v/5.3.0)包的重新导出。例如，可使用`useLocation`获取当前页面的[location](https://developer.mozilla.org/en-US/docs/Web/API/Location)，使用`useHistory`访问[history对象](https://developer.mozilla.org/en-US/docs/Web/API/History)。（它们虽然功能相似，但不同于浏览器API。具体API请参考React Router文档。）

该API具有**SSR安全性**，与仅限浏览器环境的`window.location`不同。

```jsx title="myComponent.js"
import React from 'react';
import {useLocation} from '@docusaurus/router';

export function PageRoute() {
  // React router provides the current component's route, even in SSR
  const location = useLocation();
  return (
    <span>
      We are currently on <code>{location.pathname}</code>
    </span>
  );
}
```

export function PageRoute() {
  const location = useLocation();
  return (
    <span>
      We are currently on <code>{location.pathname}</code>
    </span>
  );
}

<BrowserWindow>

<PageRoute />

</BrowserWindow>

## 规避SPA重定向机制 {#escaping-from-spa-redirects}

Docusaurus构建的是[单页应用](https://developer.mozilla.org/en-US/docs/Glossary/SPA)，其路由跳转通过React路由器的`history.push()`方法在客户端完成。但该操作的前提是目标URL已被我们的路由器识别，否则路由器会拦截路径并显示404页面。

若将HTML页面置于`static`文件夹下，它们会被复制到构建输出中从而成为网站可访问内容，但这些内容不属于Docusaurus路由系统。我们提供`pathname://`协议，允许以非SPA方式重定向到域名的其他部分，如同该路由是外部链接。

```md
- [pathname:///pure-html](pathname:///pure-html)
```

<BrowserWindow>

- [`pathname:///pure-html`](pathname:///pure-html)

</BrowserWindow>

`pathname://`协议适用于引用static文件夹中的任何内容。例如，Docusaurus会将[所有Markdown静态资源转换为require()调用](../guides/markdown-features/markdown-features-assets.mdx#static-assets)。使用`pathname://`可保持其为普通链接，避免被Webpack哈希处理。

```md title="my-doc.md"
![An image from the static](pathname:///img/docusaurus.png)

[An asset from the static](pathname:///files/asset.pdf)
```

Docusaurus仅会移除`pathname://`前缀而不处理内容。