---
description: "Docusaurus' routing system follows single-page application conventions: one route, one component."
---

# 路由系统

import Link from '@docusaurus/Link';
import {useLatestVersion, useActiveDocContext} from '@docusaurus/plugin-content-docs/client';
import {useLocation} from '@docusaurus/router';
import BrowserWindow from '@site/src/components/BrowserWindow';

Docusaurus的路由系统遵循单页应用(SPA)规范：一个路由对应一个组件。本节将首先介绍三大内容插件（文档、博客和页面）内部的路由机制，进而深入探讨底层路由系统。

## 内容插件中的路由 {#routing-in-content-plugins}

每个内容插件都提供`routeBasePath`配置项，用于定义插件路由的挂载基点。默认情况下，文档插件将路由置于`/docs`下，博客插件使用`/blog`，页面插件则使用`/`。路由结构可理解为：

```mermaid
graph LR;
    A(["https://example.com/"])
    B(["/base-url/"])
    C(["/docs/"])
    D(["/blog/"])
    E(["/"])
    F["All docs <br/>routes"]
    G["All blog <br/>routes"]
    H["All pages <br/>routes"]
    A---B;
    B---C;
    B---D;
    B---E;
    C---F;
    D---G;
    E---H;
```

系统会逐级匹配路由直至找到对应配置。例如当访问`/docs/configuration`时，Docusaurus会先进入`/docs`分支，然后在文档插件创建的子路由中继续查找。

修改`routeBasePath`可重构站点路由体系。如在[纯文档模式](../guides/docs/docs-introduction.mdx#docs-only-mode)中，将文档插件的`routeBasePath`设为`'/'`意味着所有文档路由将去除`/docs`前缀，同时仍允许其他插件创建如`/blog`的子路由。

接下来我们具体分析三大插件的子路由结构。

### 页面路由 {#pages-routing}

页面路由采用直接映射机制：文件路径即URL路径，不支持其他定制方式。详见[页面文档](../guides/creating-pages.mdx#routing)。

Markdown页面的渲染组件为`@theme/MDXPage`，React页面则直接作为路由组件使用。

### 博客路由 {#blog-routing}

博客插件创建以下路由：

- **文章列表页**：`/`、`/page/2`、`/page/3`...
  - 使用`@theme/BlogListPage`组件
- **文章详情页**：`/2021/11/21/algolia-docsearch-migration`、`/2021/05/12/announcing-docusaurus-two-beta`...
  - 由各Markdown文章生成
  - 可通过`slug`前置元数据完全自定义路由
  - 使用`@theme/BlogPostPage`组件
- **标签列表页**：`/tags`
  - 路由可通过`tagsBasePath`配置修改
  - 使用`@theme/BlogTagsListPage`组件
- **标签聚合页**：`/tags/adoption`、`/tags/beta`...
  - 根据文章前置元数据中的标签生成
  - 基础路由由`tagsBasePath`定义，子路由可通过标签的`permalink`字段定制
  - 使用`@theme/BlogTagsPostsPage`组件
- **归档页**：`/archive`
  - 路由可通过`archiveBasePath`配置修改
  - 使用`@theme/BlogArchivePage`组件

### 文档路由 {#docs-routing}

文档插件是唯一支持**嵌套路由**的插件。顶层注册[版本路径](../guides/docs/versioning.mdx)：`/`、`/next`、`/2.0.0-beta.13`...这些路径提供版本上下文（包括布局和侧边栏），保证切换文档时侧边栏状态得以保持，同时可通过导航栏下拉菜单切换版本而不离开当前文档。使用`@theme/DocPage`组件。

export const URLPath = () => <code>{useLocation().pathname}</code>;

export const FilePath = () => {
  const currentVersion = useActiveDocContext('default').activeVersion.name;
  return <code>{currentVersion === 'current' ? './docs/' : `./versioned_docs/version-${currentVersion}/`}advanced/routing.md</code>;
}

具体文档内容在导航栏、页脚、侧边栏等`DocPage`组件提供的框架内渲染。例如当前页面<URLPath />由文件<FilePath />生成，使用`@theme/DocItem`组件。

文档的 `slug` 前置元数据可自定义路由的最后部分，但基础路由始终由插件的 `routeBasePath` 和版本的 `path` 定义。

### 文件路径与URL路径 {#file-paths-and-url-paths}

在文档中，我们始终明确区分文件路径和URL路径。内容插件通常将文件路径直接映射为URL路径，例如 `./docs/advanced/routing.md` 会转换为 `/docs/advanced/routing`。但通过 `slug` 配置，可以使URL与文件结构完全解耦。

在Markdown中编写链接时，可能指向文件路径或URL路径，Docusaurus会通过以下启发式规则进行判断：

- 带 `@site` 前缀的路径始终视为资源文件路径
- 带 `http(s)://` 前缀的路径始终视为URL路径
- 无扩展名的路径视为URL路径。例如在URL为 `/docs/advanced/routing` 的页面上，链接 `[page](../plugins)` 将指向 `/docs/plugins`。Docusaurus仅在构建时（当知晓完整路由结构后）检测损坏链接，不会对文件存在性做假设。这等同于在JSX文件中编写 `<a href="../plugins">page</a>`
- 带 `.md(x)` 扩展名的路径，Docusaurus会尝试解析该Markdown文件对应的URL路径
- 其他扩展名的路径将被视为[静态资源](../guides/markdown-features/markdown-features-assets.mdx)并由Webpack打包处理

以下目录结构可帮助理解文件→URL的映射关系（假设所有页面均未使用slug自定义）：

<details>

<summary>A sample site structure</summary>

```bash
.
├── blog                            # blog plugin has routeBasePath: '/blog'
│   ├── 2019-05-28-first-blog-post.md       # -> /blog/2019/05/28/first-blog-post
│   ├── 2019-05-29-long-blog-post.md        # -> /blog/2019/05/29/long-blog-post
│   ├── 2021-08-01-mdx-blog-post.mdx        # -> /blog/2021/08/01/mdx-blog-post
│   └── 2021-08-26-welcome
│       ├── docusaurus-plushie-banner.jpeg
│       └── index.md                        # -> /blog/2021/08/26/welcome
├── docs                            # docs plugin has routeBasePath: '/docs'; current version has base path '/'
│   ├── intro.md                            # -> /docs/intro
│   ├── tutorial-basics
│   │   ├── _category_.json
│   │   ├── congratulations.md              # -> /docs/tutorial-basics/congratulations
│   │   └── markdown-features.mdx           # -> /docs/tutorial-basics/markdown-features
│   └── tutorial-extras
│       ├── _category_.json
│       ├── manage-docs-versions.md         # -> /docs/tutorial-extras/manage-docs-versions
│       └── translate-your-site.md          # -> /docs/tutorial-extras/translate-your-site
├── src
│   └── pages                       # pages plugin has routeBasePath: '/'
│       ├── index.module.css
│       ├── index.tsx                       # -> /
│       └── markdown-page.md                # -> /markdown-page
└── versioned_docs
    └── version-1.0.0               # version has base path '/1.0.0'
        ├── intro.md                        # -> /docs/1.0.0/intro
        ├── tutorial-basics
        │   ├── _category_.json
        │   ├── congratulations.md          # -> /docs/1.0.0/tutorial-basics/congratulations
        │   └── markdown-features.mdx       # -> /docs/1.0.0/tutorial-basics/congratulations
        └── tutorial-extras
            ├── _category_.json
            ├── manage-docs-versions.md     # -> /docs/1.0.0/tutorial-extras/manage-docs-versions
            └── translate-your-site.md      # -> /docs/1.0.0/tutorial-extras/translate-your-site
```

</details>

关于内容插件的路由就介绍到这里。现在让我们退一步，讨论Docusaurus应用中的通用路由机制。

## 路由生成HTML文件 {#routes-become-html-files}

由于Docusaurus是服务端渲染框架，所有生成的路由都会被服务端渲染为静态HTML文件。熟悉[Apache2](https://httpd.apache.org/docs/trunk/getting-started.html)等HTTP服务器行为的用户会理解其原理：当浏览器请求 `/docs/advanced/routing` 路由时，服务器会将其解释为请求 `/docs/advanced/routing/index.html` 文件并返回。

`/docs/advanced/routing` 路由可能对应 `/docs/advanced/routing/index.html` 或 `/docs/advanced/routing.html`。部分托管服务商根据尾部斜杠进行区分，可能对另一种形式兼容性不同。详见[尾部斜杠指南](https://github.com/slorber/trailing-slash-guide)。

例如上述目录结构的构建输出如下（忽略其他资源和JS包）：

<details>

<summary>Output of the above workspace</summary>

```bash
build
├── 404.html                      # /404/
├── blog
│   ├── archive
│   │   └── index.html            # /blog/archive/
│   ├── first-blog-post
│   │   └── index.html            # /blog/first-blog-post/
│   ├── index.html                # /blog/
│   ├── long-blog-post
│   │   └── index.html            # /blog/long-blog-post/
│   ├── mdx-blog-post
│   │   └── index.html            # /blog/mdx-blog-post/
│   ├── tags
│   │   ├── docusaurus
│   │   │   └── index.html        # /blog/tags/docusaurus/
│   │   ├── hola
│   │   │   └── index.html        # /blog/tags/hola/
│   │   └── index.html            # /blog/tags/
│   └── welcome
│       └── index.html            # /blog/welcome/
├── docs
│   ├── 1.0.0
│   │   ├── intro
│   │   │   └── index.html        # /docs/1.0.0/intro/
│   │   ├── tutorial-basics
│   │   │   ├── congratulations
│   │   │   │   └── index.html    # /docs/1.0.0/tutorial-basics/congratulations/
│   │   │   └── markdown-features
│   │   │       └── index.html    # /docs/1.0.0/tutorial-basics/markdown-features/
│   │   └── tutorial-extras
│   │       ├── manage-docs-versions
│   │       │   └── index.html    # /docs/1.0.0/tutorial-extras/manage-docs-versions/
│   │       └── translate-your-site
│   │           └── index.html    # /docs/1.0.0/tutorial-extras/translate-your-site/
│   ├── intro
│   │   └── index.html            # /docs/1.0.0/intro/
│   ├── tutorial-basics
│   │   ├── congratulations
│   │   │   └── index.html        # /docs/tutorial-basics/congratulations/
│   │   └── markdown-features
│   │       └── index.html        # /docs/tutorial-basics/markdown-features/
│   └── tutorial-extras
│       ├── manage-docs-versions
│       │   └── index.html        # /docs/tutorial-extras/manage-docs-versions/
│       └── translate-your-site
│           └── index.html        # /docs/tutorial-extras/translate-your-site/
├── index.html                    # /
└── markdown-page
    └── index.html                # /markdown-page/
```

</details>

若将 `trailingSlash` 设为 `false`，构建时将生成 `intro.html` 而非 `intro/index.html`。

所有HTML文件都使用绝对URL引用其JS资源，因此必须配置 `baseUrl` 字段以确保正确加载资源。注意 `baseUrl` 不会影响构建产物的文件结构：基础URL位于Docusaurus路由系统之上。您可以将 `url` 和 `baseUrl` 的组合视为Docusaurus站点的实际部署位置。

例如，生成的HTML文件会包含类似`<link rel="preload" href="/assets/js/runtime~main.7ed5108a.js" as="script">`的链接。由于绝对URL是从主机地址解析的，如果打包文件部署在`https://example.com/base/`路径下，该链接将指向不存在的`https://example.com/assets/js/runtime~main.7ed5108a.js`。通过指定`/base/`作为基础URL，链接才能正确指向`/base/assets/js/runtime~main.7ed5108a.js`。

多语言站点的基础URL会包含语言标识。例如`https://docusaurus.io/zh-CN/docs/advanced/routing/`的基础URL是`/zh-CN/`。

## 路由的生成与访问 {#generating-and-accessing-routes}

`addRoute`生命周期操作用于生成路由。它向路由树注册路由配置，提供路由路径、组件及组件所需的props。props和组件都以路径形式提供给打包器进行`require`调用，正如[架构概述](architecture.mdx)所述，服务端与客户端仅通过临时文件通信。

所有路由都聚合在`.docusaurus/routes.js`中，可通过调试插件的[路由面板](/__docusaurus/debug/routes)查看。

在客户端，我们提供`@docusaurus/router`来访问页面路由。该模块是[`react-router-dom`](https://www.npmjs.com/package/react-router-dom/v/5.3.0)的二次导出。例如可使用`useLocation`获取当前页面的[location对象](https://developer.mozilla.org/en-US/docs/Web/API/Location)，或通过`useHistory`访问[history对象](https://developer.mozilla.org/en-US/docs/Web/API/History)。（注意这些API虽功能相似，但不同于浏览器原生API，具体用法请参考React Router文档。）

该API具有**SSR安全性**，与仅限浏览器环境的`window.location`不同。

```jsx title="myComponent.js"
import React from 'react';
import {useLocation} from '@docusaurus/router';

export function PageRoute() {
  // React router provides the current component's route, even in SSR
  const location = useLocation();
  return (
    <span>
      We are currently on <code>{location.pathname}</code>
    </span>
  );
}
```

export function PageRoute() {
  const location = useLocation();
  return (
    <span>
      We are currently on <code>{location.pathname}</code>
    </span>
  );
}

<BrowserWindow>

<PageRoute />

</BrowserWindow>

## 规避SPA重定向机制 {#escaping-from-spa-redirects}

Docusaurus构建的是[单页应用](https://developer.mozilla.org/en-US/docs/Glossary/SPA)，其路由跳转通过React Router的`history.push()`方法实现。这种操作发生在客户端，但前提是目标URL必须被路由系统识别，否则路由器会拦截该路径并显示404页面。

若将HTML文件置于`static`文件夹，它们会被复制到构建输出目录从而成为网站可访问内容，但这些路径不属于Docusaurus路由系统。我们提供`pathname://`协议，允许以非SPA方式跳转到站内其他路径（如同外部链接）。

```md
- [pathname:///pure-html](pathname:///pure-html)
```

<BrowserWindow>

- [`pathname:///pure-html`](pathname:///pure-html)

</BrowserWindow>

`pathname://`协议特别适用于引用static文件夹中的内容。例如Docusaurus会将[所有Markdown静态资源转换为require()调用](../guides/markdown-features/markdown-features-assets.mdx#static-assets)，使用该协议可保持原始链接形式，避免被Webpack哈希处理。

```md title="my-doc.md"
![An image from the static](pathname:///img/docusaurus.png)

[An asset from the static](pathname:///files/asset.pdf)
```

Docusaurus仅会移除`pathname://`前缀而不对内容做进一步处理。